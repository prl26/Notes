# 关于go的一细节

## 1.=和:=的区别?

 	=是赋值运算符; 

​	:= 是声明和赋值运算符

## 2.new和make的区别:

​	new的返回是一个地址类型的

​       而make的返回时一个值类型的

## 3.如何高效的拼接字符串:

   string的join

  fmt.sprintf

 string.builder

## 4.如何知道一个对象是分配在栈上还是堆上

​	首先局部变量通常来说分配在栈上,全局变量通常分配在堆上

​	但是go有逃逸分析,在某些特殊情况会用到,比如

如果一个函数返回一个指向局部变量的指针，这个局部变量会逃逸到堆上。

如果一个局部变量被传递给一个新的 goroutine，并且在 goroutine 内部继续使用，那么它会逃逸到堆上。

如果一个局部变量作为参数传递给其他函数，并且在被调用的函数内部被保留（即它的生命周期延长到了被调用的函数内部），那么它可能会逃逸到堆上。

## 5.简述go语言gc(垃圾回收)的工作原理(不同go版本,gc回收方法不同)

最开始似乎是通过标记-清楚+stw的方法,然后逐渐过渡到了三色标记法.目前所使用的应该是一种三色标记法与混合写屏障的结合

## 6.无缓冲的chanel和有缓冲的channel的区别

​	无缓冲的channel必须同时有读和写的操作,不然会阻塞

## 7.简述go语言的GMP调度原理

![image-20231102153210199](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20231102153210199.png)

G:gorountine

M:thread

P:processor

- 全局队列（Global Queue）：存放等待运行的 G。
- P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。
- P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。
- M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。

## 8.slice的底层实现

​	底层就是一个数组的引用

## 9.channel的底层实现

## 10.map的底层实现

​	map应该是哈希表的底层实现,数组+链表

## 11.reflect的底层实现